<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>EasyRoute Visualizer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.css' rel='stylesheet' />
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #1a1a2e; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }

        .panel {
            position: absolute; top: 12px; left: 12px;
            background: white; padding: 16px; border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            max-width: 340px; max-height: calc(100vh - 24px);
            overflow-y: auto; z-index: 1; font-size: 13px;
        }
        .panel::-webkit-scrollbar { width: 4px; }
        .panel::-webkit-scrollbar-thumb { background: #d0d0d0; border-radius: 2px; }
        .panel-title { margin: 0 0 12px; font-size: 17px; font-weight: 700; letter-spacing: -0.3px; }

        .tabs { display: flex; background: #f0f0f5; border-radius: 8px; padding: 3px; margin-bottom: 14px; }
        .tab {
            flex: 1; padding: 7px 0; cursor: pointer; border: none; width: auto;
            background: none; font-size: 12px; color: #666; border-radius: 6px;
            font-weight: 500; transition: all 0.15s;
        }
        .tab:hover { color: #333; }
        .tab.active { background: white; color: #4264fb; box-shadow: 0 1px 3px rgba(0,0,0,0.08); font-weight: 600; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        .form-group { margin-bottom: 10px; }
        .form-label { display: block; font-size: 11px; color: #999; margin-bottom: 3px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.4px; }
        input[type="number"], input[type="text"], select {
            width: 100%; padding: 8px 10px; border: 1px solid #e0e0e5;
            border-radius: 8px; font-size: 13px; background: #f8f8fb;
            transition: border-color 0.15s, background 0.15s; font-family: inherit;
        }
        input:focus, select:focus { outline: none; border-color: #4264fb; background: white; }
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

        button { font-family: inherit; }
        .btn-primary {
            background: #4264fb; color: white; border: none;
            padding: 10px; border-radius: 8px; cursor: pointer;
            width: 100%; font-size: 13px; font-weight: 600; transition: background 0.15s;
        }
        .btn-primary:hover { background: #3451cc; }
        .btn-primary:disabled { background: #a0b0f0; cursor: not-allowed; }
        .btn-sm {
            background: #f0f0f5; color: #555; border: none;
            padding: 5px 10px; border-radius: 6px; cursor: pointer;
            font-size: 11px; font-weight: 500; width: auto; transition: all 0.15s;
        }
        .btn-sm:hover { background: #e0e0e8; }

        .sync-row { display: flex; align-items: center; gap: 6px; margin: 4px 0 10px; }
        .sync-toggle {
            position: relative; width: 30px; height: 17px;
            background: #d0d0d5; border-radius: 9px; cursor: pointer;
            transition: background 0.2s; flex-shrink: 0;
        }
        .sync-toggle.on { background: #28a745; }
        .sync-toggle::after {
            content: ''; position: absolute; top: 2px; left: 2px;
            width: 13px; height: 13px; background: white; border-radius: 50%;
            transition: transform 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .sync-toggle.on::after { transform: translateX(13px); }
        .sync-label { font-size: 11px; color: #999; user-select: none; }

        .cat-dropdown { position: relative; }
        .cat-trigger {
            width: 100%; padding: 8px 10px; border: 1px solid #e0e0e5;
            border-radius: 8px; font-size: 12px; background: #f8f8fb;
            cursor: pointer; display: flex; justify-content: space-between;
            align-items: center; color: #555; transition: border-color 0.15s;
        }
        .cat-trigger:hover { border-color: #c0c0c5; }
        .cat-trigger .arrow { font-size: 9px; color: #aaa; transition: transform 0.15s; }
        .cat-trigger .arrow.open { transform: rotate(180deg); }
        .cat-popover {
            display: none; position: fixed;
            background: white; border: 1px solid #e0e0e5; border-radius: 10px;
            padding: 10px; z-index: 100; box-shadow: 0 8px 24px rgba(0,0,0,0.12);
            max-height: 220px; overflow-y: auto;
        }
        .cat-popover.open { display: block; }
        .cat-popover-actions {
            display: flex; justify-content: flex-end; gap: 8px;
            margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid #f0f0f0;
        }
        .cat-popover-actions a { font-size: 11px; color: #4264fb; cursor: pointer; text-decoration: none; font-weight: 500; }
        .cat-popover-actions a:hover { text-decoration: underline; }
        .cat-group-name {
            font-size: 10px; color: #aaa; font-weight: 600; text-transform: uppercase;
            letter-spacing: 0.3px; margin: 8px 0 4px; display: block;
        }
        .cat-group-name:first-child { margin-top: 0; }
        .cat-pill {
            display: inline-block; padding: 3px 9px; margin: 2px;
            border-radius: 10px; font-size: 11px; cursor: pointer;
            border: 1.5px solid; transition: all 0.12s; font-weight: 500;
        }
        .cat-pill.on { color: white; }
        .cat-pill:not(.on) { background: white; opacity: 0.6; }
        .cat-pill:hover { opacity: 1; }

        .route-section { margin-top: 14px; padding-top: 14px; border-top: 1px solid #eee; }
        .route-section h4 { margin: 0 0 8px; font-size: 12px; font-weight: 600; color: #999; text-transform: uppercase; letter-spacing: 0.3px; }
        .route-card {
            padding: 10px 12px; margin: 5px 0;
            background: #f8f8fb; border-radius: 8px; cursor: pointer;
            border: 1.5px solid transparent; transition: all 0.12s;
        }
        .route-card:hover { background: #f0f0f8; border-color: #d0d4f0; }
        .route-card.selected { background: #4264fb; color: white; border-color: #4264fb; }
        .route-card .rc-title { font-weight: 600; font-size: 13px; }
        .route-card .rc-meta { font-size: 11px; margin-top: 3px; opacity: 0.75; }

        .metrics-grid {
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 2px 10px; font-size: 11px; margin-top: 8px;
            padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.2);
        }
        .metrics-grid dt { opacity: 0.7; }
        .metrics-grid dd { margin: 0; font-weight: 600; }

        #poiFilter { margin-top: 10px; padding-top: 10px; border-top: 1px solid #eee; }
        #poiFilter .filter-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
        #poiFilter .filter-header span:first-child { font-weight: 600; font-size: 12px; }
        .filter-links a { font-size: 11px; color: #4264fb; cursor: pointer; margin-left: 8px; text-decoration: none; }
        .filter-links a:hover { text-decoration: underline; }
        .filter-btn {
            display: inline-block; padding: 2px 8px; margin: 2px;
            border: 1.5px solid #ccc; border-radius: 12px;
            font-size: 11px; cursor: pointer; background: white; color: #333; width: auto; transition: all 0.12s;
        }
        .filter-btn.active { border-color: transparent; color: white; }
        .filter-btn.inactive { opacity: 0.3; }

        .poi-marker {
            width: 28px; height: 28px; border-radius: 50%; border: 2px solid white;
            display: flex; align-items: center; justify-content: center;
            color: white; font-weight: 700; font-size: 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.25);
        }
        .snapped-poi-marker {
            width: 18px; height: 18px; border-radius: 50%;
            border: 2px solid white; box-shadow: 0 1px 4px rgba(0,0,0,0.2);
        }
        .start-marker {
            background: #00D084; width: 22px; height: 22px; border-radius: 50%;
            border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.25);
        }

        .map-crosshair {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 26px; height: 26px; pointer-events: none; z-index: 2;
        }
        .map-crosshair::before, .map-crosshair::after {
            content: ''; position: absolute; background: rgba(40,167,69,0.6); border-radius: 1px;
        }
        .map-crosshair::before { left: 50%; top: 0; width: 2px; height: 100%; transform: translateX(-50%); }
        .map-crosshair::after { top: 50%; left: 0; width: 100%; height: 2px; transform: translateY(-50%); }

        .map-center-display {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.65); color: white;
            padding: 4px 10px; border-radius: 6px;
            font-size: 11px; font-family: 'SF Mono', Menlo, monospace;
            z-index: 2; pointer-events: none; backdrop-filter: blur(4px);
        }

        .error { background: #fef2f2; color: #dc2626; padding: 10px; border-radius: 8px; font-size: 12px; margin-top: 10px; border: 1px solid #fecaca; }
        .loading { opacity: 0.6; pointer-events: none; }
        .api-input {
            width: 100%; min-height: 90px; margin: 6px 0; padding: 10px;
            border: 1px solid #e0e0e5; border-radius: 8px;
            font-family: 'SF Mono', Menlo, monospace; font-size: 12px;
            background: #f8f8fb; resize: vertical;
        }
        .api-input:focus { outline: none; border-color: #4264fb; background: white; }
        .btn-coverage {
            background: #f0f0f5; color: #666; border: none;
            padding: 7px; border-radius: 8px; cursor: pointer;
            font-size: 11px; font-weight: 500; width: 100%; transition: all 0.15s; margin-top: 10px;
        }
        .btn-coverage:hover { background: #e0e0e8; }
        .btn-coverage.on { background: #4264fb; color: white; }
        .checkbox-row { display: flex; align-items: center; gap: 6px; margin-bottom: 10px; }
        .checkbox-row input[type="checkbox"] { width: auto; margin: 0; accent-color: #4264fb; }
        .checkbox-row label { font-size: 12px; color: #666; cursor: pointer; }

        .export-row { display: flex; gap: 6px; margin-top: 10px; }
        .btn-export {
            flex: 1; padding: 6px 0; border: 1.5px solid #e0e0e5; border-radius: 6px;
            background: white; color: #555; font-size: 11px; font-weight: 500;
            cursor: pointer; transition: all 0.15s; font-family: inherit;
        }
        .btn-export:hover { border-color: #4264fb; color: #4264fb; }
    </style>
</head>
<body>

<div id="map">
    <div class="map-crosshair"></div>
    <div class="map-center-display" id="mapCenterDisplay">48.8566, 2.3522</div>
</div>

<div class="panel">
    <div class="panel-title">EasyRoute</div>
    <div class="tabs">
        <button class="tab active" onclick="switchTab('generate')">Generate</button>
        <button class="tab" onclick="switchTab('paste')">Paste JSON</button>
    </div>

    <div id="generateTab" class="tab-content active">
        <div class="form-group">
            <label class="form-label">API Endpoint</label>
            <input type="text" id="apiEndpoint" value="http://localhost:3000">
        </div>
        <div class="form-group">
            <label class="form-label">Route Type</label>
            <select id="routeType" onchange="updateRouteTypeFields()">
                <option value="loop">Loop Route</option>
                <option value="point-to-point">Point-to-Point</option>
            </select>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label class="form-label">Start Lat</label>
                <input type="number" id="startLat" value="48.8566" step="0.0001">
            </div>
            <div class="form-group">
                <label class="form-label">Start Lng</label>
                <input type="number" id="startLng" value="2.3522" step="0.0001">
            </div>
        </div>
        <div class="sync-row">
            <div class="sync-toggle on" id="syncToggle" onclick="toggleSync()"></div>
            <span class="sync-label">Sync with map center</span>
        </div>
        <div id="endPointFields" style="display: none;">
            <div class="form-row">
                <div class="form-group">
                    <label class="form-label">End Lat</label>
                    <input type="number" id="endLat" value="48.8606" step="0.0001">
                </div>
                <div class="form-group">
                    <label class="form-label">End Lng</label>
                    <input type="number" id="endLng" value="2.3376" step="0.0001">
                </div>
            </div>
            <button class="btn-sm" onclick="setFromMapCenter('end')" style="margin-bottom:10px">Use map center</button>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label class="form-label">Distance (km)</label>
                <input type="number" id="distance" value="5.0" step="0.5" min="0.5" max="50">
            </div>
            <div class="form-group">
                <label class="form-label">Mode</label>
                <select id="mode">
                    <option value="walk">Walking</option>
                    <option value="bike">Cycling</option>
                </select>
            </div>
        </div>
        <div class="form-group">
            <label class="form-label">POI Categories</label>
            <div class="cat-dropdown" id="catDropdown">
                <div class="cat-trigger" onclick="toggleCatPopover()">
                    <span id="catLabel">All categories</span>
                    <span class="arrow" id="catArrow">&#9662;</span>
                </div>
                <div class="cat-popover" id="catPopover">
                    <div class="cat-popover-actions">
                        <a onclick="selectAllCats()">All</a>
                        <a onclick="clearAllCats()">None</a>
                    </div>
                    <div id="catPills"></div>
                </div>
            </div>
        </div>
        <div class="checkbox-row">
            <input type="checkbox" id="hiddenGems">
            <label for="hiddenGems">Prefer hidden gems</label>
        </div>
        <button class="btn-primary" onclick="generateRoute()" id="generateBtn">Generate Route</button>
        <div id="errorMsg" style="display: none;"></div>
    </div>

    <div id="pasteTab" class="tab-content">
        <p style="font-size:12px;color:#999;margin:0 0 6px">Paste API response JSON:</p>
        <textarea class="api-input" id="apiResponse" placeholder='{"routes": [...]}'></textarea>
        <button class="btn-primary" onclick="visualizeRoutes()">Visualize</button>
    </div>

    <button class="btn-coverage" id="coverageBtn" onclick="toggleCoverage()">Show POI Coverage</button>
    <div id="routeInfo" class="route-section" style="display: none;"></div>
    <div id="poiFilter" style="display: none;"></div>
</div>

<script>
    // ── Category data ──────────────────────────────────────────
    const POI_CATEGORIES = {
        'Original': {
            monument: { label: 'Monument', color: '#e74c3c' },
            viewpoint: { label: 'Viewpoint', color: '#e67e22' },
            park: { label: 'Park', color: '#27ae60' },
            museum: { label: 'Museum', color: '#8e44ad' },
            restaurant: { label: 'Restaurant', color: '#d35400' },
            cafe: { label: 'Cafe', color: '#a0522d' },
            historic: { label: 'Historic', color: '#c0392b' },
            cultural: { label: 'Cultural', color: '#9b59b6' },
        },
        'Natural / Scenic': {
            waterfront: { label: 'Waterfront', color: '#2980b9' },
            waterfall: { label: 'Waterfall', color: '#1abc9c' },
            nature_reserve: { label: 'Nature Reserve', color: '#16a085' },
        },
        'Architectural': {
            church: { label: 'Church', color: '#7f8c8d' },
            castle: { label: 'Castle', color: '#8B4513' },
            bridge: { label: 'Bridge', color: '#607D8B' },
            tower: { label: 'Tower', color: '#795548' },
        },
        'Urban Interest': {
            plaza: { label: 'Plaza', color: '#f39c12' },
            fountain: { label: 'Fountain', color: '#3498db' },
            market: { label: 'Market', color: '#e67e22' },
            artwork: { label: 'Artwork', color: '#e91e63' },
            lighthouse: { label: 'Lighthouse', color: '#ffc107' },
        },
        'Activity': {
            winery: { label: 'Winery', color: '#722f37' },
            brewery: { label: 'Brewery', color: '#d4a017' },
            theatre: { label: 'Theatre', color: '#ad1457' },
            library: { label: 'Library', color: '#5c6bc0' },
        },
    };

    const CATEGORY_INFO = {};
    for (const cats of Object.values(POI_CATEGORIES)) Object.assign(CATEGORY_INFO, cats);

    const selectedCats = new Set(); // empty = all categories
    let catPopoverOpen = false;

    function buildCatPills() {
        const el = document.getElementById('catPills');
        for (const [group, cats] of Object.entries(POI_CATEGORIES)) {
            const g = document.createElement('span');
            g.className = 'cat-group-name'; g.textContent = group;
            el.appendChild(g);
            for (const [key, info] of Object.entries(cats)) {
                const p = document.createElement('span');
                p.className = 'cat-pill'; p.textContent = info.label;
                p.dataset.cat = key;
                p.style.borderColor = info.color; p.style.color = info.color;
                p.onclick = () => toggleCat(key, p);
                el.appendChild(p);
            }
        }
    }

    function toggleCat(key, pill) {
        const info = CATEGORY_INFO[key];
        if (selectedCats.has(key)) {
            selectedCats.delete(key);
            pill.classList.remove('on'); pill.style.background = 'white'; pill.style.color = info.color;
        } else {
            selectedCats.add(key);
            pill.classList.add('on'); pill.style.background = info.color; pill.style.color = 'white';
        }
        updateCatLabel();
    }

    function selectAllCats() {
        document.querySelectorAll('#catPills .cat-pill').forEach(p => {
            const info = CATEGORY_INFO[p.dataset.cat]; selectedCats.add(p.dataset.cat);
            p.classList.add('on'); p.style.background = info.color; p.style.color = 'white';
        });
        updateCatLabel();
    }

    function clearAllCats() {
        document.querySelectorAll('#catPills .cat-pill').forEach(p => {
            const info = CATEGORY_INFO[p.dataset.cat]; selectedCats.delete(p.dataset.cat);
            p.classList.remove('on'); p.style.background = 'white'; p.style.color = info.color;
        });
        updateCatLabel();
    }

    function updateCatLabel() {
        const n = selectedCats.size, total = Object.keys(CATEGORY_INFO).length;
        const label = document.getElementById('catLabel');
        if (n === 0 || n === total) label.textContent = 'All categories';
        else if (n <= 2) label.textContent = [...selectedCats].map(k => CATEGORY_INFO[k].label).join(', ');
        else label.textContent = n + ' categories selected';
    }

    function toggleCatPopover() {
        catPopoverOpen = !catPopoverOpen;
        const popover = document.getElementById('catPopover');
        const arrow = document.getElementById('catArrow');
        popover.classList.toggle('open', catPopoverOpen);
        arrow.classList.toggle('open', catPopoverOpen);
        if (catPopoverOpen) {
            const rect = document.querySelector('.cat-trigger').getBoundingClientRect();
            popover.style.top = (rect.bottom + 4) + 'px';
            popover.style.left = rect.left + 'px';
            popover.style.width = rect.width + 'px';
        }
    }

    document.addEventListener('click', e => {
        if (catPopoverOpen && !document.getElementById('catDropdown').contains(e.target)) {
            catPopoverOpen = false;
            document.getElementById('catPopover').classList.remove('open');
            document.getElementById('catArrow').classList.remove('open');
        }
    });

    // ── Map setup ──────────────────────────────────────────────
    mapboxgl.accessToken = window.MAPBOX_TOKEN || prompt('Enter your Mapbox access token:');
    const map = new mapboxgl.Map({
        container: 'map', style: 'mapbox://styles/mapbox/streets-v12',
        center: [2.3522, 48.8566], zoom: 12
    });
    map.addControl(new mapboxgl.NavigationControl());

    let currentMarkers = [], currentRoutes = null, selectedRouteIndex = 0;
    let hiddenCategories = new Set();

    // ── Sync coordinates with map center ───────────────────────
    let syncEnabled = true, _suppressSync = false;

    function toggleSync() {
        syncEnabled = !syncEnabled;
        document.getElementById('syncToggle').classList.toggle('on', syncEnabled);
        if (syncEnabled) syncCoordsFromMap();
    }

    function syncCoordsFromMap() {
        if (!syncEnabled || _suppressSync) return;
        const c = map.getCenter();
        document.getElementById('startLat').value = c.lat.toFixed(4);
        document.getElementById('startLng').value = c.lng.toFixed(4);
    }

    function updateMapCenter() {
        const c = map.getCenter();
        document.getElementById('mapCenterDisplay').textContent = c.lat.toFixed(4) + ', ' + c.lng.toFixed(4);
        syncCoordsFromMap();
    }
    map.on('move', updateMapCenter);

    // Disable sync on manual coordinate edit
    ['startLat', 'startLng'].forEach(id => {
        document.getElementById(id).addEventListener('input', () => {
            if (syncEnabled) { syncEnabled = false; document.getElementById('syncToggle').classList.remove('on'); }
        });
    });

    // ── UI helpers ─────────────────────────────────────────────
    function switchTab(tab) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        event.target.classList.add('active');
        document.getElementById('generateTab').classList.toggle('active', tab === 'generate');
        document.getElementById('pasteTab').classList.toggle('active', tab !== 'generate');
    }

    function updateRouteTypeFields() {
        document.getElementById('endPointFields').style.display =
            document.getElementById('routeType').value === 'point-to-point' ? 'block' : 'none';
    }

    function setFromMapCenter(which) {
        const c = map.getCenter();
        document.getElementById(which + 'Lat').value = c.lat.toFixed(4);
        document.getElementById(which + 'Lng').value = c.lng.toFixed(4);
    }

    function mkEl(cls, color, text) {
        const el = document.createElement('div');
        el.className = cls;
        if (color) el.style.backgroundColor = color;
        if (text !== undefined) el.textContent = text;
        return el;
    }

    // ── Generate route via API ─────────────────────────────────
    async function generateRoute() {
        const btn = document.getElementById('generateBtn');
        const err = document.getElementById('errorMsg');
        const panel = document.querySelector('.panel');
        err.style.display = 'none'; err.className = '';
        btn.disabled = true; btn.textContent = 'Generating...'; panel.classList.add('loading');

        try {
            const api = document.getElementById('apiEndpoint').value.trim();
            const type = document.getElementById('routeType').value;
            const lat = parseFloat(document.getElementById('startLat').value);
            const lng = parseFloat(document.getElementById('startLng').value);
            const dist = parseFloat(document.getElementById('distance').value);
            const mode = document.getElementById('mode').value;
            if (!api) throw new Error('API endpoint required');
            if (isNaN(lat) || isNaN(lng)) throw new Error('Invalid start coordinates');
            if (isNaN(dist) || dist <= 0) throw new Error('Invalid distance');

            const body = { start_point: { lat, lng }, distance_km: dist, mode };
            if (type === 'point-to-point') {
                const eLat = parseFloat(document.getElementById('endLat').value);
                const eLng = parseFloat(document.getElementById('endLng').value);
                if (isNaN(eLat) || isNaN(eLng)) throw new Error('Invalid end coordinates');
                body.end_point = { lat: eLat, lng: eLng };
            }
            const prefs = {};
            if (selectedCats.size > 0 && selectedCats.size < Object.keys(CATEGORY_INFO).length)
                prefs.poi_categories = [...selectedCats];
            if (document.getElementById('hiddenGems').checked) prefs.hidden_gems = true;
            if (Object.keys(prefs).length) body.preferences = prefs;

            const endpoint = type === 'loop' ? '/api/v1/routes/loop' : '/api/v1/routes/point-to-point';
            console.log('API call:', api + endpoint, body);
            const resp = await fetch(api + endpoint, {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            if (!resp.ok) throw new Error('API error (' + resp.status + '): ' + await resp.text());

            const data = await resp.json();
            currentRoutes = data.routes;
            if (!currentRoutes?.length) throw new Error('No routes returned');
            displayRouteInfo(); displayRoute(0);
        } catch (e) {
            console.error(e);
            err.className = 'error'; err.textContent = e.message; err.style.display = 'block';
        } finally {
            btn.disabled = false; btn.textContent = 'Generate Route'; panel.classList.remove('loading');
        }
    }

    function visualizeRoutes() {
        try {
            const data = JSON.parse(document.getElementById('apiResponse').value);
            currentRoutes = data.routes;
            if (!currentRoutes?.length) { alert('No routes in response'); return; }
            displayRouteInfo(); displayRoute(0);
        } catch (e) { alert('Invalid JSON: ' + e.message); }
    }

    // ── Route info panel ───────────────────────────────────────
    function displayRouteInfo() {
        const div = document.getElementById('routeInfo');
        div.style.display = 'block';
        let h = '<h4>Routes</h4>';
        currentRoutes.forEach((r, i) => {
            h += '<div class="route-card ' + (i === selectedRouteIndex ? 'selected' : '') + '" onclick="displayRoute(' + i + ')">'
                + '<div class="rc-title">Route ' + (i + 1) + '</div>'
                + '<div class="rc-meta">' + r.distance_km.toFixed(1) + ' km &middot; '
                + r.estimated_duration_minutes + ' min &middot; Score ' + r.score.toFixed(1) + '/10<br>'
                + r.pois.length + ' waypoints'
                + (r.snapped_pois ? ' &middot; ' + r.snapped_pois.length + ' nearby' : '') + '</div></div>';
        });
        h += '<div class="export-row">'
            + '<button class="btn-export" onclick="exportGPX()">GPX</button>'
            + '<button class="btn-export" onclick="exportGoogleMaps()">Google Maps</button>'
            + '<button class="btn-export" onclick="exportGeoJSON()">GeoJSON</button>'
            + '</div>';
        div.innerHTML = h;
    }

    function renderMetrics(m) {
        if (!m) return '';
        return '<dl class="metrics-grid">'
            + '<dt>Circularity</dt><dd>' + (m.circularity * 100).toFixed(0) + '%</dd>'
            + '<dt>Convexity</dt><dd>' + (m.convexity * 100).toFixed(0) + '%</dd>'
            + '<dt>Overlap</dt><dd>' + (m.path_overlap_pct * 100).toFixed(0) + '%</dd>'
            + '<dt>POI density</dt><dd>' + m.poi_density_per_km.toFixed(1) + '/km</dd>'
            + '<dt>Entropy</dt><dd>' + m.category_entropy.toFixed(2) + '</dd>'
            + '<dt>Landmark</dt><dd>' + (m.landmark_coverage * 100).toFixed(0) + '%</dd>'
            + '<dt>Density</dt><dd>' + m.poi_density_context + '</dd></dl>';
    }

    // ── Display route on map ───────────────────────────────────
    function displayRoute(idx) {
        selectedRouteIndex = idx;
        const route = currentRoutes[idx];
        clearMap(); hiddenCategories.clear();

        const coords = route.path.map(c => [c.lng, c.lat]);
        if (map.getSource('route')) {
            map.getSource('route').setData({ type: 'Feature', geometry: { type: 'LineString', coordinates: coords } });
        } else {
            map.addSource('route', { type: 'geojson', data: { type: 'Feature', geometry: { type: 'LineString', coordinates: coords } } });
            map.addLayer({ id: 'route', type: 'line', source: 'route',
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: { 'line-color': '#4264fb', 'line-width': 4 } });
        }

        // Start marker
        const s = route.path[0];
        const sm = new mapboxgl.Marker(mkEl('start-marker'))
            .setLngLat([s.lng, s.lat]).setPopup(new mapboxgl.Popup().setHTML('<strong>Start/End</strong>')).addTo(map);
        currentMarkers.push({ marker: sm, category: null, type: 'start' });

        // Waypoint POIs
        route.pois.forEach(poi => {
            const cat = poi.category, color = (CATEGORY_INFO[cat] || {}).color || '#4264fb';
            const el = mkEl('poi-marker', color, poi.order_in_route); el.dataset.category = cat;
            const popup = '<strong>' + poi.name + '</strong> (Waypoint)<br>Category: ' + cat
                + '<br>Popularity: ' + poi.popularity_score.toFixed(0) + '/100'
                + (poi.description ? '<br>' + poi.description : '')
                + '<br>Distance: ' + poi.distance_from_start_km.toFixed(1) + ' km';
            const m = new mapboxgl.Marker(el).setLngLat([poi.coordinates.lng, poi.coordinates.lat])
                .setPopup(new mapboxgl.Popup().setHTML(popup)).addTo(map);
            currentMarkers.push({ marker: m, category: cat, type: 'waypoint' });
        });

        // Snapped POIs
        if (route.snapped_pois) {
            route.snapped_pois.forEach(poi => {
                const cat = poi.category, color = (CATEGORY_INFO[cat] || {}).color || '#ff9500';
                const el = mkEl('snapped-poi-marker', color); el.dataset.category = cat;
                const popup = '<strong>' + poi.name + '</strong> (Nearby)<br>Category: ' + cat
                    + '<br>Popularity: ' + poi.popularity_score.toFixed(0) + '/100'
                    + (poi.description ? '<br>' + poi.description : '')
                    + '<br>From path: ' + poi.distance_from_path_m.toFixed(0) + 'm'
                    + ' &middot; Along: ' + poi.distance_from_start_km.toFixed(1) + ' km';
                const m = new mapboxgl.Marker(el).setLngLat([poi.coordinates.lng, poi.coordinates.lat])
                    .setPopup(new mapboxgl.Popup().setHTML(popup)).addTo(map);
                currentMarkers.push({ marker: m, category: cat, type: 'snapped' });
            });
        }

        // Fit bounds, suppress sync during animation
        const bounds = new mapboxgl.LngLatBounds();
        coords.forEach(c => bounds.extend(c));
        _suppressSync = true;
        map.fitBounds(bounds, { padding: 50 });
        map.once('moveend', () => { _suppressSync = false; });

        displayRouteInfo(); buildPoiFilter();
        const cards = document.querySelectorAll('.route-card');
        if (cards[idx]) cards[idx].insertAdjacentHTML('beforeend', renderMetrics(route.metrics));
    }

    // ── POI filter ─────────────────────────────────────────────
    function buildPoiFilter() {
        const div = document.getElementById('poiFilter');
        const cats = new Set();
        currentMarkers.forEach(m => { if (m.category) cats.add(m.category); });
        if (!cats.size) { div.style.display = 'none'; return; }

        div.style.display = 'block';
        let h = '<div class="filter-header"><span>Filter POIs</span><span class="filter-links">'
            + '<a onclick="setAllFilters(true)">All</a><a onclick="setAllFilters(false)">None</a></span></div>';
        for (const cat of [...cats].sort()) {
            const info = CATEGORY_INFO[cat] || { label: cat, color: '#888' };
            h += '<button class="filter-btn active" style="background:' + info.color
                + ';border-color:transparent;color:white" onclick="toggleCategoryFilter(\'' + cat + '\',this)">'
                + info.label + '</button>';
        }
        div.innerHTML = h;
    }

    function toggleCategoryFilter(cat, btn) {
        const info = CATEGORY_INFO[cat] || { color: '#888' };
        if (hiddenCategories.has(cat)) {
            hiddenCategories.delete(cat);
            btn.className = 'filter-btn active';
            btn.style.background = info.color; btn.style.borderColor = 'transparent'; btn.style.color = 'white';
        } else {
            hiddenCategories.add(cat);
            btn.className = 'filter-btn inactive';
            btn.style.background = 'white'; btn.style.borderColor = '#ccc'; btn.style.color = '#333';
        }
        applyMarkerVis();
    }

    function setAllFilters(show) {
        hiddenCategories.clear();
        if (!show) currentMarkers.forEach(m => { if (m.category) hiddenCategories.add(m.category); });
        document.querySelectorAll('#poiFilter .filter-btn').forEach(btn => {
            const label = btn.textContent.trim();
            for (const [k, info] of Object.entries(CATEGORY_INFO)) {
                if (info.label === label) {
                    if (show) { btn.className = 'filter-btn active'; btn.style.background = info.color; btn.style.borderColor = 'transparent'; btn.style.color = 'white'; }
                    else { btn.className = 'filter-btn inactive'; btn.style.background = 'white'; btn.style.borderColor = '#ccc'; btn.style.color = '#333'; }
                    break;
                }
            }
        });
        applyMarkerVis();
    }

    function applyMarkerVis() {
        currentMarkers.forEach(m => {
            if (!m.category) return;
            m.marker.getElement().style.display = hiddenCategories.has(m.category) ? 'none' : '';
        });
    }

    function clearMap() { currentMarkers.forEach(m => m.marker.remove()); currentMarkers = []; }

    // ── Coverage overlay ───────────────────────────────────────
    let coverageOn = false;

    async function toggleCoverage() {
        const btn = document.getElementById('coverageBtn');
        if (coverageOn) {
            if (map.getLayer('coverage-fill')) map.removeLayer('coverage-fill');
            if (map.getLayer('coverage-outline')) map.removeLayer('coverage-outline');
            if (map.getSource('coverage')) map.removeSource('coverage');
            coverageOn = false; btn.textContent = 'Show POI Coverage'; btn.classList.remove('on');
            return;
        }
        btn.textContent = 'Loading...'; btn.disabled = true;
        try {
            const api = document.getElementById('apiEndpoint').value.trim();
            const resp = await fetch(api + '/api/v1/debug/coverage');
            const data = await resp.json();
            if (data.error) throw new Error(data.error);
            if (!data.coverage) throw new Error('No POI data');

            const gj = { type: 'Feature', geometry: data.coverage };
            if (map.getSource('coverage')) map.getSource('coverage').setData(gj);
            else map.addSource('coverage', { type: 'geojson', data: gj });

            if (!map.getLayer('coverage-fill'))
                map.addLayer({ id: 'coverage-fill', type: 'fill', source: 'coverage',
                    paint: { 'fill-color': 'rgba(66,100,251,0.1)', 'fill-outline-color': 'rgba(66,100,251,0.4)' } });
            if (!map.getLayer('coverage-outline'))
                map.addLayer({ id: 'coverage-outline', type: 'line', source: 'coverage',
                    paint: { 'line-color': 'rgba(66,100,251,0.6)', 'line-width': 2, 'line-dasharray': [4, 2] } });

            const bounds = new mapboxgl.LngLatBounds();
            const g = data.coverage;
            if (g.type === 'Polygon') g.coordinates[0].forEach(c => bounds.extend(c));
            else if (g.type === 'MultiPolygon') g.coordinates.forEach(p => p[0].forEach(c => bounds.extend(c)));
            _suppressSync = true;
            map.fitBounds(bounds, { padding: 50 });
            map.once('moveend', () => { _suppressSync = false; });

            coverageOn = true;
            btn.textContent = 'Hide Coverage (' + data.poi_count + ' POIs, ' + (data.cluster_count || '?') + ' regions)';
            btn.classList.add('on');
        } catch (e) {
            console.error(e); alert('Coverage failed: ' + e.message);
            btn.textContent = 'Show POI Coverage';
        } finally { btn.disabled = false; }
    }

    // ── Export helpers ─────────────────────────────────────────
    function escapeXML(s) {
        return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;').replace(/'/g, '&apos;');
    }

    function downloadFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename;
        document.body.appendChild(a); a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function exportGPX() {
        const route = currentRoutes[selectedRouteIndex];
        if (!route) return;
        const name = 'EasyRoute Loop — ' + route.distance_km.toFixed(1) + ' km';
        let gpx = '<?xml version="1.0" encoding="UTF-8"?>\n'
            + '<gpx version="1.1" creator="EasyRoute"\n'
            + '  xmlns="http://www.topografix.com/GPX/1/1"\n'
            + '  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n'
            + '  xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">\n'
            + '  <metadata><name>' + escapeXML(name) + '</name></metadata>\n';

        // Waypoint POIs
        route.pois.forEach(poi => {
            gpx += '  <wpt lat="' + poi.coordinates.lat + '" lon="' + poi.coordinates.lng + '">\n'
                + '    <name>' + escapeXML(poi.name) + '</name>\n'
                + '    <desc>' + escapeXML('Waypoint #' + poi.order_in_route + ' — ' + poi.category) + '</desc>\n'
                + '  </wpt>\n';
        });

        // Snapped POIs
        (route.snapped_pois || []).forEach(poi => {
            gpx += '  <wpt lat="' + poi.coordinates.lat + '" lon="' + poi.coordinates.lng + '">\n'
                + '    <name>' + escapeXML(poi.name) + '</name>\n'
                + '    <desc>' + escapeXML('Nearby — ' + poi.category) + '</desc>\n'
                + '  </wpt>\n';
        });

        // Track
        gpx += '  <trk><name>' + escapeXML(name) + '</name><trkseg>\n';
        route.path.forEach(p => {
            gpx += '    <trkpt lat="' + p.lat + '" lon="' + p.lng + '"></trkpt>\n';
        });
        gpx += '  </trkseg></trk>\n</gpx>\n';

        downloadFile(gpx, 'easyroute-' + route.distance_km.toFixed(1) + 'km.gpx', 'application/gpx+xml');
    }

    function exportGoogleMaps() {
        const route = currentRoutes[selectedRouteIndex];
        if (!route) return;
        const start = route.path[0];
        const origin = start.lat + ',' + start.lng;
        const mode = document.getElementById('mode').value;
        const travelMode = mode === 'bike' ? 'bicycling' : 'walking';

        const waypoints = route.pois
            .slice()
            .sort((a, b) => a.order_in_route - b.order_in_route)
            .slice(0, 8)
            .map(p => p.coordinates.lat + ',' + p.coordinates.lng)
            .join('|');

        let url = 'https://www.google.com/maps/dir/?api=1'
            + '&origin=' + encodeURIComponent(origin)
            + '&destination=' + encodeURIComponent(origin)
            + '&travelmode=' + travelMode;
        if (waypoints) url += '&waypoints=' + encodeURIComponent(waypoints);

        window.open(url, '_blank');
    }

    function exportGeoJSON() {
        const route = currentRoutes[selectedRouteIndex];
        if (!route) return;
        const features = [];

        // Route line
        features.push({
            type: 'Feature',
            geometry: { type: 'LineString', coordinates: route.path.map(p => [p.lng, p.lat]) },
            properties: {
                type: 'route', distance_km: route.distance_km,
                duration_minutes: route.estimated_duration_minutes, score: route.score
            }
        });

        // Waypoint POIs
        route.pois.forEach(poi => {
            features.push({
                type: 'Feature',
                geometry: { type: 'Point', coordinates: [poi.coordinates.lng, poi.coordinates.lat] },
                properties: {
                    type: 'waypoint', name: poi.name, category: poi.category,
                    order: poi.order_in_route, popularity: poi.popularity_score
                }
            });
        });

        // Snapped POIs
        (route.snapped_pois || []).forEach(poi => {
            features.push({
                type: 'Feature',
                geometry: { type: 'Point', coordinates: [poi.coordinates.lng, poi.coordinates.lat] },
                properties: {
                    type: 'nearby', name: poi.name, category: poi.category,
                    distance_from_path_m: poi.distance_from_path_m
                }
            });
        });

        const geojson = JSON.stringify({ type: 'FeatureCollection', features }, null, 2);
        downloadFile(geojson, 'easyroute-' + route.distance_km.toFixed(1) + 'km.geojson', 'application/geo+json');
    }

    // ── Init ───────────────────────────────────────────────────
    buildCatPills();
    updateMapCenter();
</script>

</body>
</html>
